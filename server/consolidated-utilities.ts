/**
 * Consolidated Utilities Module
 * Auto-generated by Codebase Consolidation Engine
 */

export class ConsolidatedUtilities {
  // Rate limiting utility
  static rateLimitCache = new Map<string, { count: number; resetTime: number }>();
  
  static async rateLimit(key: string, limit: number, windowMs: number): Promise<boolean> {
    const now = Date.now();
    const entry = this.rateLimitCache.get(key);
    
    if (!entry || now > entry.resetTime) {
      this.rateLimitCache.set(key, { count: 1, resetTime: now + windowMs });
      return true;
    }
    
    if (entry.count >= limit) {
      return false;
    }
    
    entry.count++;
    return true;
  }
  
  // Caching utility
  static cache = new Map<string, { data: any; expiry: number }>();
  
  static setCache(key: string, data: any, ttlMs: number): void {
    this.cache.set(key, { data, expiry: Date.now() + ttlMs });
  }
  
  static getCache<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry || Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    return entry.data;
  }
  
  // Retry utility with exponential backoff
  static async retryWithBackoff<T>(
    fn: () => Promise<T>,
    maxRetries = 3,
    baseDelayMs = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt === maxRetries) {
          throw lastError;
        }
        
        const delay = baseDelayMs * Math.pow(2, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    throw lastError!;
  }
  
  // Performance monitoring
  static async measurePerformance<T>(
    name: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const start = performance.now();
    try {
      const result = await fn();
      const duration = performance.now() - start;
      console.log(`‚ö° ${name}: ${duration.toFixed(2)}ms`);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      console.log(`‚ùå ${name} failed after ${duration.toFixed(2)}ms`);
      throw error;
    }
  }

  // Price aggregation utility
  static async aggregatePrices(prices: Array<{ price: number; confidence: number }>): Promise<number> {
    if (prices.length === 0) return 0;
    
    // Calculate weighted average based on confidence
    const weightedSum = prices.reduce((sum, p) => sum + (p.price * p.confidence), 0);
    const totalWeight = prices.reduce((sum, p) => sum + p.confidence, 0);
    
    return weightedSum / totalWeight;
  }

  // Error handling utility
  static handleApiError(error: any, source: string): void {
    if (error?.status === 429) {
      console.log(`‚è∞ Rate limited by ${source}`);
    } else if (error?.status >= 500) {
      console.log(`üîß Server error from ${source}: ${error.status}`);
    } else {
      console.log(`‚ùå API error from ${source}:`, error);
    }
  }
}